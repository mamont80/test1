Создание очереди.
 channel.queue_declare(queue='hello')

Есть имя очереди а есть имя точки обмена(exchange)

Посылаем сообщение в очередь с ТО по умолчанию.
channel.basic_publish(exchange='',
                      routing_key='hello',
                      body='Hello World!')

необходимо убедиться, что буфер был очищен и сообщение дошло до RabbitMQ
connection.close()

когда мы обращаемся к очереди без наименовании, мы создаем временную очередь и автоматически сгенерированным наименованием:
list($queue_name, ,) = $channel->queue_declare("");
Метод вернет автоматически сгенерированное имя очереди. Она может быть такой – ‘amq.gen-JzTY20BRgKO-HjmUJj0wLg.’.
Когда заявленное соединение оборвется, очередь автоматически удалиться.

У каждой очереди есть 4 флага определяющих ее поведение:
    auto_delete — если очередь пустая и к ней нет активных подключений, очередь автоматически удаляется
    durable — устойчивая очередь, сообщения не теряются при рестарте rabbitMQ (или внезапной перезагрузке), при публикации и до окончания отдачи хранятся в базе данных
    exclusive — очередь предназначена для не более чем одного подключения единовременно
    passive — при объявлении очереди пассивной, при обращении клиента сервер будет считать что очередь уже создана, т.е. не будет автоматически создавать ее в случае отсутствия, этот вариант нужен если вы хотите обратиться к серверу не изменяя его состояние. Например, вам просто нужно проверить существует ли очередь. Для этого объявляете очередь пассивной, и если получаете ошибку, значит очередь не существует.

Точки обмена могут быть 4 типов:
    direct — сообщения попавшие в эту точку обмена будут скопированы только в те очереди, которые связаны с точкой обмена строгим ключом маршрутизации.
    topic — ключ маршрутизации может быть составным, и задаваться в виде паттерна, для чего существуют два специальных символа: 
* — обозначает одно слово, # — одно или несколько слов. Слова разделяются точкой. Пример: routingKey = "*.database" — все сообщения с ключами в которых вторым словом значится database будут скопированы в привязанные по паттерну очереди.
    headers — очередь связывается с точкой обмена не по ключу маршрутизации, а по заголовку сообщения, указывается условие, какие аргументы и их значения ожидаются,
 и при получении точкой обмена сообщения с заголовком содержащим аргументы из условия, очередь его получает. Пример можно посмотреть тут.
    fanout — сообщение поступившее в точку обмена копируется во все привязанные очереди, без проверки ключа маршрутизации или заголовка сообщения.

noLocal - правда, если сервер не должен доставить к этому потребительских сообщений, опубликованных на связи этого канала 
qos - ограничить одновременную отправку нескольких сообщений на одного клиента

Ограничение времени жизни сообщений в очереди
                        Dictionary<string, object> dic = new Dictionary<string, object>();
                        dic.Add("x-message-ttl", 1);
                        ch.QueueDeclare(ServerQName, false, false, false, dic);

реализация семафора
while (true) {
  QueueingConsumer.Delivery delivery = consumer.nextDelivery();
  // here we access the resource controlled by the semaphore.  
  if(shouldStopProcessing()) {
    channel.basicReject(delivery.getEnvelope().getDeliveryTag(), true);
  }
}

basicNack - для группового возврата сообщений. Пример:
GetResponse gr1 = channel.basicGet("some.queue", false);
GetResponse gr2 = channel.basicGet("some.queue", false);
channel.basicNack(gr2.getEnvelope().getDeliveryTag(), true, true);

Для durable очереди нужно устанавливать SetPersistent свойство у сообщений

main_database="DRIVER={SQL Server};Server=192.168.14.21;Uid=Maps1410;Pwd=8ewREh4z;Database=Catalog;MultipleActiveResultSets=True"
failover_database="DRIVER={SQL Server};Server=192.168.14.22;Uid=Maps1410;Pwd=8ewREh4z;Database=Catalog;MultipleActiveResultSets=True"

Настройка RabbitMQ.
Писать хостнейм в верхнем регистре.
Синхронизация и зеркалирование очередей
rabbitmqctl set_policy ha-two "^" "{""ha-mode"":""all"",""ha-sync-mode"":""automatic""}"

Добавление юзера
rabbitmqctl add_user username password
делаем админом
rabbitmqctl set_user_tags username administrator
